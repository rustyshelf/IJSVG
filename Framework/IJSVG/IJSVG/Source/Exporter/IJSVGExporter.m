//
//  IJSVGExporter.m
//  IJSVGExample
//
//  Created by Curtis Hard on 06/01/2017.
//  Copyright Â© 2017 Curtis Hard. All rights reserved.
//

#import <IJSVG/IJSVG.h>
#import <IJSVG/IJSVGExporter.h>
#import <IJSVG/IJSVGExporterPathInstruction.h>
#import <IJSVG/IJSVGGradientLayer.h>
#import <IJSVG/IJSVGGroupLayer.h>
#import <IJSVG/IJSVGImageLayer.h>
#import <IJSVG/IJSVGLinearGradient.h>
#import <IJSVG/IJSVGMath.h>
#import <IJSVG/IJSVGPatternLayer.h>
#import <IJSVG/IJSVGRadialGradient.h>
#import <IJSVG/IJSVGShapeLayer.h>
#import <IJSVG/IJSVGStrokeLayer.h>
#import <IJSVG/IJSVGFilterLayer.h>
#import <IJSVG/IJSVGTransformLayer.h>
#import <IJSVG/IJSVGParser.h>

@implementation IJSVGExporter

#define XML_DOC_VERSION 1.1f
#define XML_DOC_NS @"http://www.w3.org/2000/svg"
#define XML_DOC_NSXLINK @"http://www.w3.org/1999/xlink"
#define XML_DOCTYPE_VERSION @"1.0"
#define XML_DOC_CHARSET @"UTF-8"
#define XML_DOC_GENERATOR @"Generated by IJSVG (https://github.com/iconjar/IJSVG)"

static char IJSVGExporterIgnoreElementKey;
static char IJSVGExporterInsertAfterElementsKey;
static char IJSVGExporterInsertBeforeElementsKey;

BOOL IJSVGExporterHasOption(IJSVGExporterOptions options, NSInteger option)
{
    return (options & option) != 0;
};

const NSArray<NSString*>* IJSVGShortCharacterArray(void)
{
    static NSArray* _array;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _array = @[ @"a", @"b", @"c", @"d", @"e", @"f", @"g", @"h", @"i", @"j", @"k", @"l",
            @"m", @"n", @"o", @"p", @"q", @"r", @"s", @"t", @"u", @"v", @"w", @"x", @"y", @"z",
            @"A", @"B", @"C", @"D", @"E", @"F", @"G", @"H", @"I", @"J", @"K", @"L",
            @"M", @"N", @"O", @"P", @"Q", @"R", @"S", @"T", @"U", @"V", @"W", @"X", @"Y", @"Z" ];
    });
    return _array;
}

const NSDictionary<NSString*, NSString*>* IJSVGDefaultAttributes(void)
{
    static NSDictionary* _defaults;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _defaults = @{
            IJSVGAttributeClipPath: IJSVGStringNone,
            IJSVGAttributeClipRule: @"nonzero",
            IJSVGAttributeMask: IJSVGStringNone,
            IJSVGAttributeOpacity: @"1",
            IJSVGAttributeStopColor: @"#000",
            IJSVGAttributeStopOpacity: @"1",
            IJSVGAttributeFillOpacity: @"1",
            IJSVGAttributeFillRule: @"nonzero",
            IJSVGAttributeFill: @"#000",
            IJSVGAttributeStroke: IJSVGStringNone,
            IJSVGAttributeStrokeWidth: @"1",
            IJSVGAttributeStrokeLineCap: @"butt",
            IJSVGAttributeStrokeLineJoin: IJSVGStringMiter,
            IJSVGAttributeStrokeMiterLimit: @"4",
            IJSVGAttributeStrokeDashArray: IJSVGStringNone,
            IJSVGAttributeStrokeDashOffset: @"0",
            IJSVGAttributeStrokeOpacity: @"1",
            IJSVGAttributeDisplay: @"inline",
            IJSVGAttributePreserveAspectRatio: @"xMidYMid"
        };
    });
    return _defaults;
}

const NSArray* IJSVGInheritableAttributes(void)
{
    static NSArray* _attributes;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _attributes = @[
            IJSVGAttributeClipRule,
            IJSVGAttributeFill,
            IJSVGAttributeFillOpacity,
            IJSVGAttributeFillRule,
            IJSVGAttributeStroke,
            IJSVGAttributeStrokeDashArray,
            IJSVGAttributeStrokeDashOffset,
            IJSVGAttributeStrokeLineCap,
            IJSVGAttributeStrokeLineJoin,
            IJSVGAttributeStrokeMiterLimit,
            IJSVGAttributeStrokeOpacity,
            IJSVGAttributeStrokeWidth,
        ];
    });
    return _attributes;
}

void IJSVGApplyAttributesToElement(NSDictionary* _Nonnull attributes, NSXMLElement* element)
{
    [element setAttributesAsDictionary:attributes];
};

NSDictionary<NSString*, NSString*>* IJSVGElementAttributeDictionary(NSXMLElement* element)
{
    NSArray* atts = element.attributes;
    NSMutableDictionary* dict = [[NSMutableDictionary alloc] initWithCapacity:atts.count];
    for (NSXMLNode* attribute in atts) {
        dict[attribute.name] = attribute.stringValue;
    }
    return dict;
};

NSString* IJSVGHashURL(NSString* key)
{
    return [NSString stringWithFormat:@"url(#%@)", key];
};

NSString* IJSVGHash(NSString* key)
{
    return [@"#" stringByAppendingString:key];
}

- (id)initWithSVG:(IJSVG*)svg
             size:(CGSize)size
          options:(IJSVGExporterOptions)options
{
    IJSVGFloatingPointOptions fpo = IJSVGFloatingPointOptionsDefault();
    return [self initWithSVG:svg
                        size:size
                     options:options
        floatingPointOptions:fpo];
}

- (id)initWithSVG:(IJSVG*)svg
             size:(CGSize)size
          options:(IJSVGExporterOptions)options
    floatingPointOptions:(IJSVGFloatingPointOptions)floatingPointOptions
{
    if((self = [super init]) != nil) {
        _options = options;
        _size = size;
        _svg = svg;

        // defaults for floating point rounding, if any
        _floatingPointOptions = floatingPointOptions;
    }
    return self;
}

- (void)setDelegate:(id<IJSVGExporterDelegate>)delegate
{
    _delegate = delegate;
    _respondsTo.identifierForElement = [delegate respondsToSelector:@selector(svgExporter:identifierForElement:type:defaultID:)];
    _respondsTo.stringForColor = [delegate respondsToSelector:@selector(svgExporter:stringForColor:flags:options:)];
}

- (NSXMLElement*)defElement
{
    if(_defElement != nil) {
        return _defElement;
    }
    return _defElement = [[NSXMLElement alloc] initWithName:@"defs"];
}

- (NSString*)viewBoxWithRect:(NSRect)rect
{
    return [NSString stringWithFormat:@"%@ %@ %@ %@",
        IJSVGShortFloatStringWithOptions(CGRectGetMinX(rect), _floatingPointOptions),
        IJSVGShortFloatStringWithOptions(CGRectGetMinY(rect), _floatingPointOptions),
        IJSVGShortFloatStringWithOptions(CGRectGetWidth(rect), _floatingPointOptions),
        IJSVGShortFloatStringWithOptions(CGRectGetHeight(rect), _floatingPointOptions)
    ];
}

- (NSXMLElement*)rootNode
{
    // generates the root document
    NSXMLElement* root = [[NSXMLElement alloc] initWithName:@"svg"];
    
    [self applyDefaultsForRoot:_svg.rootLayer
                     toElement:root];
        
    [root removeAttributeForName:IJSVGAttributeWidth];
    [root removeAttributeForName:IJSVGAttributeHeight];

    // sort out viewbox
    CGRect viewBox = _svg.viewBox;
    CGRect originalViewBox = viewBox;
    NSMutableDictionary* attributes = [[NSMutableDictionary alloc] initWithDictionary:@{
        IJSVGAttributeXMLNS: XML_DOC_NS
    }];

    // add on various XML declaritive things
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionRemoveXMLDeclaration) == NO) {
        attributes[IJSVGAttributeVersion] = [NSString stringWithFormat:@"%g", XML_DOC_VERSION];
    }
    
    // passing in zero size will just use default. If the SVG had a dynamic
    // size to begin with (width and height were % based) it will use the original
    // values from those, else it will do rounding on the values.
    // passing in a CGSize with infinite size will omit the dimension attributes
    CGSize proposedSize = _size;
    IJSVGIntrinsicDimensions dimensions = IJSVGIntrinsicDimensionBoth;
    if(CGSizeEqualToSize(proposedSize, IJSVGSizeIntrinsic) == YES) {
        dimensions = _svg.intrinsicDimensions;
        if(_svg.hasDynamicSize == YES) {
            dimensions = IJSVGIntrinsicDimensionNone;
        }
        proposedSize = _svg.size;
    } else if(CGSizeEqualToSize(proposedSize, IJSVGSizeInfinite) == YES) {
        dimensions = IJSVGIntrinsicDimensionNone;
    }
    
    // do we need to resize the viewbox?
    CGFloat scale = 1.f;
    if(CGSizeEqualToSize(CGSizeZero, _size) == NO &&
       CGSizeEqualToSize(viewBox.size, _size) == NO) {
        scale = MIN(proposedSize.width / viewBox.size.width,
                    proposedSize.height / viewBox.size.height);
        viewBox = CGRectMake(CGRectGetMinX(viewBox) * scale,
                             CGRectGetMinY(viewBox) * scale,
                             proposedSize.width / scale,
                             proposedSize.height / scale);
    }
    
    // do we need to center it within its viewbox
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionCenterWithinViewBox) == YES) {
        CGPoint origin = CGPointMake((proposedSize.width / scale) / 2.f - originalViewBox.size.width / 2.f,
                                     (proposedSize.height / scale) / 2.f - originalViewBox.size.height /  2.f);
        CGAffineTransform transform = CGAffineTransformMakeTranslation(-origin.x, -origin.y);
        viewBox = CGRectApplyAffineTransform(viewBox, transform);
    }

    // only add dimentions if required
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionRemoveWidthHeightAttributes) == NO) {
        if(dimensions == IJSVGIntrinsicDimensionNone && _svg.hasDynamicSize == YES) {
            IJSVGUnitSize* dynamicSize = _svg.rootNode.intrinsicSize;
            attributes[IJSVGAttributeWidth] = dynamicSize.width.stringValue;
            attributes[IJSVGAttributeHeight] = dynamicSize.height.stringValue;
        } else {
            if((dimensions & IJSVGIntrinsicDimensionWidth) == IJSVGIntrinsicDimensionWidth) {
                attributes[IJSVGAttributeWidth] = IJSVGShortFloatStringWithOptions(proposedSize.width,
                                                                                   _floatingPointOptions);
            }
            if((dimensions & IJSVGIntrinsicDimensionHeight) == IJSVGIntrinsicDimensionHeight) {
                attributes[IJSVGAttributeHeight] = IJSVGShortFloatStringWithOptions(proposedSize.height,
                                                                                    _floatingPointOptions);
            }
        }
    }
    attributes[IJSVGAttributeViewBox] = [self viewBoxWithRect:viewBox];
    IJSVGApplyAttributesToElement(attributes, root);
    return root;
}

- (void)applyXLinkToRootElement
{
    // simply flag check
    if(_appliedXLink == YES) {
        return;
    }

    // set and add the attribute onto the rootElement
    _appliedXLink = YES;
    NSXMLElement* root = _dom.rootElement;
    IJSVGApplyAttributesToElement(@{
        IJSVGAttributeXMLNSXlink: XML_DOC_NSXLINK
    }, root);
}

- (NSString*)generateID
{
    const NSArray* chars = IJSVGShortCharacterArray();
    if(_idCount < chars.count) {
        return chars[_idCount++];
    }

    if((_idCount % chars.count) == 0) {
        _shortIdCount++;
    }
    return [NSString stringWithFormat:@"%@%ld", chars[(_idCount++ % chars.count)], _shortIdCount];
}

- (void)_generateDOMDocument
{
    _idCount = 0;
    _shortIdCount = 0;
    _appliedXLink = NO;
    _dom = nil;
    _defElement = nil;
    
    // create the stand alone DOM
    NSXMLElement* rootNode = [self rootNode];
    _dom = [[NSXMLDocument alloc] initWithRootElement:rootNode];
    _dom.version = XML_DOCTYPE_VERSION;
    _dom.characterEncoding = XML_DOC_CHARSET;

    // sort out stuff, so here we go...
    for(NSXMLElement* childLayer in _svg.rootLayer.sublayers) {
        [self _recursiveParseFromLayer:(CALayer<IJSVGDrawableLayer>*)childLayer
                           intoElement:rootNode];
    }

    // this needs to be added incase it needs to be cleaned
    NSXMLElement* defNode = [self defElement];
    if(defNode.childCount != 0) {
        [_dom.rootElement insertChild:[self defElement]
                              atIndex:0];
    }

    // cleanup
    [self _cleanup];

    // could had been removed during cleaning process needs to be added back in!
    if(defNode.childCount != 0 && defNode.parent == nil) {
        [_dom.rootElement insertChild:[self defElement]
                              atIndex:0];
    }

    // add generator
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionRemoveComments) == NO) {
        NSXMLNode* generatorNode = [[NSXMLNode alloc] initWithKind:NSXMLCommentKind];
        generatorNode.stringValue = XML_DOC_GENERATOR;
        [_dom.rootElement insertChild:generatorNode
                              atIndex:0];
    }
}

- (void)_cleanup
{
    // remove hidden elements
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionRemoveHiddenElements) == YES) {
        [self _removeHiddenElements];
    }

    // convert any duplicate paths into use
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionCreateUseForPaths) == YES) {
        [self _convertUseElements];
    }

    // cleanup def
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionRemoveUselessDef) == YES) {
        [self _cleanDef];
    }

    // collapse groups
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionCollapseGroups) == YES) {
        [self _collapseGroups];
    }

    // clean any blank groups
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionRemoveUselessGroups) == YES) {
        [self _cleanEmptyGroups];
    }

    // sort attributes
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionSortAttributes) == YES) {
        [self _sortAttributesOnElement:_dom.rootElement];
    }

    // compress groups together
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionCollapseGroups) == YES) {
        [self _compressGroups];
    }

    // collapse gradients?
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionCollapseGradients) == YES) {
        [self _collapseGradients];
    }

    // move attributes to group
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionMoveAttributesToGroup) == YES) {
        [self _moveAttributesToGroupWithElement:_dom.rootElement];
    }

    // any use cleaning
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionCreateUseForPaths) == YES) {
        [self _cleanupUseTransforms];
    }

    // remove any defaults
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionRemoveDefaultValues) == YES) {
        [self _removeDefaultAttributes];
    }
}

- (void)_cleanupUseTransforms
{
    NSArray<NSXMLElement*>* elements = [_dom nodesForXPath:@"//use"
                                                     error:nil];
    for (NSXMLElement* element in elements) {
        NSString* att = [element attributeForName:IJSVGAttributeTransform].stringValue;
        if(att == nil || [element attributeForName:IJSVGAttributeX] != nil ||
            [element attributeForName:IJSVGAttributeY] != nil) {
            continue;
        }

        // at this point we can move the x and y
        NSArray<IJSVGTransform*>* transforms = [IJSVGTransform transformsForString:att];
        if(transforms.count == 1 && transforms.firstObject.command == IJSVGTransformCommandTranslate) {
            IJSVGTransform* transform = transforms.firstObject;
            [element removeAttributeForName:IJSVGAttributeTransform];

            // x
            NSXMLNode* att = [[NSXMLNode alloc] initWithKind:NSXMLAttributeKind];
            att.name = IJSVGAttributeX;
            att.stringValue = IJSVGShortFloatStringWithOptions(transform.parameters[0], _floatingPointOptions);
            [element addAttribute:att];

            // y
            att = [[NSXMLNode alloc] initWithKind:NSXMLAttributeKind];
            att.name = IJSVGAttributeY;
            att.stringValue = IJSVGShortFloatStringWithOptions(transform.parameters[1], _floatingPointOptions);
            [element addAttribute:att];
        }
    }
}

- (void)_sortAttributesOnElement:(NSXMLElement*)element
{
    // only apply to XML elements, not XMLNodes
    if([element isKindOfClass:[NSXMLElement class]] == NO) {
        return;
    }
    [self sortAttributesOnElement:element];
    for (NSXMLElement* child in element.children) {
        [self _sortAttributesOnElement:child];
    }
}

- (void)_removeHiddenElements
{
    // find any elements where they have a style, but the element itself
    // must not be in the defs
    NSArray<NSXMLElement*>* elements = [_dom nodesForXPath:@"//*[@display='none']"
                                                     error:nil];

    for (NSXMLElement* element in elements) {
        NSXMLElement* parent = (NSXMLElement*)element.parent;
        [parent removeChildAtIndex:element.index];
    }
}

- (void)_collapseGradients
{
    NSString* xPath = @"//defs/*[self::linearGradient or self::radialGradient]";
    NSArray<NSXMLElement*>* gradients = [_dom nodesForXPath:xPath error:nil];
    for (NSInteger i = 0; i < gradients.count; i++) {
        if(i != 0) {
            NSXMLElement* gradientA = gradients[i];
            NSXMLElement* gradientB = nil;
            for (NSInteger s = (i - 1); s >= 0; s--) {
                gradientB = gradients[s];
                if([self compareElementChildren:gradientA toElement:gradientB] == YES) {
                    NSString* idString = [gradientB attributeForName:IJSVGAttributeID].stringValue;
                    if(idString == nil || idString.length == 0) {
                        idString = [self identifierForElement:gradientA];
                        IJSVGApplyAttributesToElement(@{
                            IJSVGAttributeID: idString
                        }, gradientB);
                    }
                    NSDictionary* atts = @{
                        IJSVGAttributeXLink: IJSVGHash(idString)
                    };
                    IJSVGApplyAttributesToElement(atts, gradientA);
                    [self applyXLinkToRootElement];
                    [gradientA setChildren:nil];
                    break;
                }
            }
        }
    }
}

- (BOOL)compareElementChildren:(NSXMLElement*)element
                     toElement:(NSXMLElement*)toElement
{
    NSArray* childrenA = element.children;
    NSArray* childrenB = toElement.children;
    if(childrenA.count != childrenB.count) {
        return NO;
    }
    for (NSInteger i = 0; i < childrenA.count; i++) {
        NSXMLElement* childA = childrenA[i];
        NSXMLElement* childB = childrenB[i];
        if([self compareElement:childA withElement:childB] == NO) {
            return NO;
        }
    }
    return YES;
}

- (void)_moveAttributesToGroupWithElement:(NSXMLElement*)parentElement
{
    const NSArray<NSString*>* excludedElements = @[ @"script", @"style", @"defs" ];
    if([excludedElements containsObject:parentElement.name]) {
        return;
    }

    const NSArray<NSString*>* inheritableAttributes = IJSVGInheritableAttributes();
    __block NSDictionary<NSString*, NSString*>* intersection = nil;
    NSMutableArray<NSXMLElement*>* currentGroup = [[NSMutableArray alloc] init];

    BOOL (^createGroupIfRequired)(void) = ^BOOL {
        // memory clean
        if(currentGroup.count < 2) {
            [currentGroup removeAllObjects];
            intersection = nil;
            return NO;
        }

        // at this point we can create a new group and remove all the attributes
        NSInteger insertIndex = currentGroup.lastObject.index;
        NSXMLElement* group = [[NSXMLElement alloc] initWithName:@"g"];
        IJSVGApplyAttributesToElement(intersection, group);

        // add back into the dom
        [(NSXMLElement*)currentGroup.lastObject.parent replaceChildAtIndex:insertIndex
                                                                  withNode:group];
        for (NSXMLElement* child in currentGroup) {
            @autoreleasepool {
                NSDictionary<NSString*, NSString*>* childIntersection = nil;
                NSDictionary<NSString*, NSString*>* childAttributes = nil;
                childAttributes = [self intersectableAttributes:IJSVGElementAttributeDictionary(child)
                                          inheritableAttributes:inheritableAttributes];
                childIntersection = [self intersectionInheritableAttributes:childAttributes
                                                          currentAttributes:intersection
                                                      inheritableAttributes:inheritableAttributes];
                for (NSString* attributeName in childIntersection.allKeys) {
                    [child removeAttributeForName:attributeName];
                }
                // move the child to the group
                [child detach];
                [group addChild:child];
            }
        }

        // memory clean
        [currentGroup removeAllObjects];
        intersection = nil;

        return YES;
    };

    for (NSInteger i = 0; i < parentElement.children.count; i++) {
        @autoreleasepool {
            // the current elements attributes that are inheritable
            NSXMLElement* element = (NSXMLElement*)parentElement.children[i];
            NSDictionary<NSString*, NSString*>* attributes = nil;
            attributes = [self intersectableAttributes:IJSVGElementAttributeDictionary(element)
                                 inheritableAttributes:inheritableAttributes];

            if(intersection == nil) {
                intersection = attributes;
                [currentGroup addObject:element];
            }

            NSXMLElement* nextSibling = element;
            while ((nextSibling = (NSXMLElement*)nextSibling.nextSibling) != nil) {
                @autoreleasepool {
                    NSDictionary<NSString*, NSString*>* siblingAttributes = nil;
                    NSDictionary<NSString*, NSString*>* siblingIntersection = nil;
                    siblingAttributes = [self intersectableAttributes:IJSVGElementAttributeDictionary(nextSibling)
                                                inheritableAttributes:inheritableAttributes];
                    siblingIntersection = [self intersectionInheritableAttributes:intersection
                                                                currentAttributes:siblingAttributes
                                                            inheritableAttributes:inheritableAttributes];
                    if(siblingIntersection == nil) {
                        createGroupIfRequired();
                        // make sure we set the index after
                        // as it could had changed whilst being added
                        // to a group
                        i = nextSibling.index - 1;
                        break;
                    }

                    // append to current list
                    [currentGroup addObject:nextSibling];
                }
            }

            // anything left over
            createGroupIfRequired();
        }
    }

    // perform the recursive calls to all children that are groups
    // including ones that were just created
    for (NSXMLElement* element in parentElement.children) {
        if([element.name isEqualToString:@"g"]) {
            [self _moveAttributesToGroupWithElement:element];
        }
    }
}

- (NSDictionary*)intersectableAttributes:(NSDictionary*)atts
                   inheritableAttributes:(const NSArray*)inheritable
{
    NSMutableDictionary* dict = [[NSMutableDictionary alloc] init];
    for (NSString* key in atts.allKeys) {
        if([inheritable containsObject:key]) {
            dict[key] = atts[key];
        }
    }
    return dict;
}

- (NSDictionary*)intersectionInheritableAttributes:(NSDictionary*)newAttributes
                                 currentAttributes:(NSDictionary*)currentAttributes
                             inheritableAttributes:(const NSArray*)inheritableAtts
{
    NSMutableDictionary* dict = [[NSMutableDictionary alloc] init];
    for (NSString* key in newAttributes.allKeys) {
        // make sure they are the same and
        // they are inheritable
        if([currentAttributes objectForKey:key] == nil) {
            return nil;
        }

        if([currentAttributes objectForKey:key] != nil &&
            [inheritableAtts containsObject:key] &&
            [newAttributes[key] isEqualToString:currentAttributes[key]]) {
            dict[key] = currentAttributes[key];
        }
    }

    // nothing to return, kill it
    if(dict.count == 0) {
        return nil;
    }
    return dict;
}

- (void)_cleanDef
{
    NSXMLElement* defNode = [self defElement];
    if(defNode.children == 0) {
        NSXMLElement* parent = (NSXMLElement*)defNode.parent;
        [parent removeChildAtIndex:defNode.index];
    }
}

- (void)_cleanEmptyGroups
{
    @autoreleasepool {
        // cleanup any groups that are completely useless
        NSArray* groups = [_dom nodesForXPath:@"//g" error:nil];
        for (NSXMLElement* element in groups) {
            NSXMLElement* parent = (NSXMLElement*)element.parent;
            if(element.childCount == 0) {
                // empty group
                [(NSXMLElement*)element.parent removeChildAtIndex:element.index];
            } else if(element.attributes.count == 0) {
                // no useful data on the group
                NSInteger index = element.index;
                for (NSXMLElement* child in element.children) {
                    [(NSXMLElement*)child.parent removeChildAtIndex:child.index];
                    [parent insertChild:child
                                atIndex:index++];
                }
                [parent removeChildAtIndex:element.index];
            }
        }
    }
}

- (void)_compressGroups
{
    NSArray* groups = [_dom nodesForXPath:@"//g" error:nil];
    for (NSXMLElement* group in groups) {

        // whats the next group?
        if(group.parent == nil) {
            continue;
        }

        // compare each group with its next sibling
        NSXMLElement* nextGroup = (NSXMLElement*)group.nextSibling;
        while ([self compareElement:group withElement:nextGroup]) {
            // move each child into the older group
            for (NSXMLElement* child in nextGroup.children) {
                [nextGroup removeChildAtIndex:child.index];
                [group addChild:child];
            }

            // remove the newer
            NSXMLElement* n = nextGroup;
            nextGroup = (NSXMLElement*)nextGroup.nextSibling;
            [(NSXMLElement*)n.parent removeChildAtIndex:n.index];
        }
    }
}

- (void)_collapseGroups
{
    NSArray* groups = [_dom nodesForXPath:@"//g" error:nil];
    const NSArray* inheritable = IJSVGInheritableAttributes();
    for (NSXMLElement* group in groups) {

        // dont do anything due to it being referenced
        if([group attributeForName:IJSVGAttributeID] != nil) {
            return;
        }

        if(group.attributes.count != 0 && group.children.count == 1) {

            // grab the first child as its a loner
            NSXMLElement* child = (NSXMLElement*)group.children[0];
            if([child attributeForName:IJSVGAttributeTransform] != nil) {
                continue;
            }

            for (NSXMLNode* gAttribute in group.attributes) {

                // if it just doesnt have the attriute, just add it
                if([child attributeForName:gAttribute.name] == NO) {
                    // remove first, or throws a wobbly
                    [group removeAttributeForName:gAttribute.name];
                    [child addAttribute:gAttribute];
                } else if([gAttribute.name isEqualToString:IJSVGAttributeTransform]) {
                    // transform requires concatination
                    NSXMLNode* childTransform = [child attributeForName:IJSVGAttributeTransform];
                    childTransform.stringValue = [NSString stringWithFormat:@"%@ %@",
                                                           gAttribute.stringValue, childTransform.stringValue];

                } else if([inheritable containsObject:gAttribute.name] == NO) {
                    // if its not inheritable, only remove it if its not equal
                    NSXMLNode* aAtt = [child attributeForName:gAttribute.name];
                    if(aAtt == nil || (aAtt != nil && [aAtt.stringValue isEqualToString:gAttribute.stringValue] == NO)) {
                        continue;
                    }
                }
                [group removeAttributeForName:gAttribute.name];
            }

            // remove the group as its useless!
            if(group.attributes.count == 0) {
                [child detach];
                [(NSXMLElement*)group.parent replaceChildAtIndex:group.index
                                                        withNode:child];
            }
        }
    }
}

- (BOOL)compareElement:(NSXMLElement*)element
           withElement:(NSXMLElement*)anotherElement
{
    // not a matching element
    if([element.name isEqualToString:anotherElement.name] == NO ||
        element.attributes.count != anotherElement.attributes.count) {
        return NO;
    }

    // compare attributes
    for (NSXMLNode* attribute in element.attributes) {
        NSString* compareString = [anotherElement attributeForName:attribute.name].stringValue;
        if([attribute.stringValue isEqualToString:compareString] == NO) {
            return NO;
        }
    }
    return YES;
}

- (void)_convertUseElements
{
    @autoreleasepool {
        NSArray* paths = [_dom nodesForXPath:@"//path"
                                       error:nil];

        NSCountedSet* set = [[NSCountedSet alloc] init];
        for (NSXMLElement* element in paths) {
            [set addObject:[element attributeForName:IJSVGAttributeD].stringValue];
        }

        NSMutableDictionary* defs = [[NSMutableDictionary alloc] init];

        // now actually compute them
        for (NSXMLElement* element in paths) {
            NSString* data = [element attributeForName:IJSVGAttributeD].stringValue;
            if([set countForObject:data] == 1) {
                continue;
            }

            // at this point, we know the path is being used more then once
            NSXMLElement* defParentElement = nil;
            if((defParentElement = [defs objectForKey:data]) == nil) {
                // create the def
                NSXMLElement* element = [[NSXMLElement alloc] init];
                element.name = @"path";

                NSDictionary* atts = @{
                    IJSVGAttributeD: data,
                    IJSVGAttributeID: [self identifierForElement:element]
                };
                IJSVGApplyAttributesToElement(atts, element);

                // store it against the def
                defs[data] = element;
                defParentElement = element;
            }

            // we know at this point, we need to swap out the path to a use
            NSXMLElement* use = [[NSXMLElement alloc] init];
            use.name = @"use";

            // grab the id
            NSString* pathId = [defParentElement attributeForName:IJSVGAttributeID].stringValue;

            NSXMLNode* useAttribute = [[NSXMLNode alloc] initWithKind:NSXMLAttributeKind];
            useAttribute.name = IJSVGAttributeXLink;
            useAttribute.stringValue = IJSVGHash(pathId);
            [use addAttribute:useAttribute];
            [self applyXLinkToRootElement];

            // remove the d attribute
            for (NSXMLNode* attribute in element.attributes) {
                if([attribute.name isEqualToString:IJSVGAttributeD]) {
                    continue;
                }
                [element removeAttributeForName:attribute.name];
                [use addAttribute:attribute];
            }

            // swap it out
            [(NSXMLElement*)element.parent replaceChildAtIndex:element.index
                                                      withNode:use];
        }

        // add the defs back in
        NSXMLElement* def = [self defElement];
        for (NSXMLElement* defElement in defs.allValues) {
            [def addChild:defElement];
        }
    }
}

- (NSString*)_computedAttribute:(NSString*)attributeName
                     forElement:(NSXMLElement*)element
{
    NSXMLNode* e = (NSXMLNode*)element;
    if(e == _dom.rootElement || e == _dom.rootDocument) {
        return nil;
    }

    NSXMLElement* el = element;
    while (el != nil) {
        NSXMLNode* attribute = [el attributeForName:attributeName];
        if(attribute != nil) {
            break;
        }
        el = (NSXMLElement*)el.parent;
        if(el == _dom.rootElement || (NSXMLNode*)el == _dom.rootDocument) {
            el = nil;
            break;
        }
    }

    NSXMLNode* attribute = [el attributeForName:attributeName];
    if(attribute) {
        return attribute.stringValue;
    }
    return nil;
}

- (void)_removeDefaultAttributesOnElement:(NSXMLElement*)element
{
    const NSDictionary<NSString*, NSString*>* defaults = IJSVGDefaultAttributes();
    const NSArray<NSString*>* inheritables = IJSVGInheritableAttributes();
    if(element.kind == NSXMLElementKind) {
        NSArray<NSXMLNode*>* attributes = element.attributes;
        if([element attributeForName:IJSVGAttributeID] == nil) {
            for (NSXMLNode* node in attributes) {
                // no value found in defaults
                NSString* val = nil;
                if((val = defaults[node.name]) == nil) {
                    continue;
                }
                BOOL isInheritable = [inheritables containsObject:node.name];
                NSString* parentComputed = [self _computedAttribute:node.name
                                                         forElement:(NSXMLElement*)element.parent];
                BOOL isDefault = [val isEqualToString:node.stringValue] && (isInheritable == NO || parentComputed == nil);
                if(isDefault) {
                    [element removeAttributeForName:node.name];
                }
            }
        }
    }
    for (NSXMLElement* childElement in element.children) {
        [self _removeDefaultAttributesOnElement:childElement];
    }
}

- (void)_removeDefaultAttributes
{
    [self _removeDefaultAttributesOnElement:_dom.rootElement];
}

- (NSXMLElement*)elementForLayer:(CALayer<IJSVGDrawableLayer>*)layer
                      fromParent:(NSXMLElement*)element
{
    // root layer
    if(layer.class == IJSVGRootLayer.class) {
        return [self elementForRoot:(IJSVGRootLayer*)layer
                         fromParent:element];
    }
    
    // shape layer
    if(layer.class == IJSVGShapeLayer.class) {
        return [self elementForShape:(IJSVGShapeLayer*)layer
                          fromParent:element];
    }
    
    // image layer
    if([layer isKindOfClass:IJSVGImageLayer.class]) {
        return [self elementForImage:(IJSVGImageLayer*)layer
                          fromParent:element];
    }
    
    // filter layer
    if(layer.class == IJSVGFilterLayer.class) {
        return [self elementForFilter:(IJSVGFilterLayer*)layer
                           fromParent:element];
    }
    
    // group layer, or layer that acts as a group
    if(layer.class == IJSVGGroupLayer.class ||
        layer.class == IJSVGTransformLayer.class ||
        layer.class == IJSVGBasicLayer.class) {
        return [self elementForGroup:layer
                          fromParent:element];
    }
    return nil;
}

- (void)_recursiveParseFromLayer:(CALayer<IJSVGDrawableLayer>*)layer
                     intoElement:(NSXMLElement*)element
{
    NSXMLElement* el = [self elementForLayer:layer
                                  fromParent:element];
    
    if(el != nil) {
        NSArray<NSXMLElement*>* beforeElements = nil;
        NSArray<NSXMLElement*>* afterElements = nil;
        NSNumber* ignore = nil;
        if((beforeElements = objc_getAssociatedObject(el, &IJSVGExporterInsertBeforeElementsKey)) != nil) {
            for(NSXMLElement* beforeElement in beforeElements) {
                [element addChild:beforeElement];
            }
        }
        if((ignore = objc_getAssociatedObject(el, &IJSVGExporterIgnoreElementKey)) == nil ||
           ignore.boolValue == NO) {
            [element addChild:el];
        }
        if((afterElements = objc_getAssociatedObject(el, &IJSVGExporterInsertAfterElementsKey)) != nil) {
            for(NSXMLElement* afterElement in afterElements) {
                [element addChild:afterElement];
            }
        }
    }
}

- (NSString*)transformAttributeStringForTransforms:(NSArray<IJSVGTransform*>*)transforms
{
    NSMutableArray* strings = [[NSMutableArray alloc] initWithCapacity:transforms.count];
    for(IJSVGTransform* transform in transforms) {
        [strings addObject:[self transformAttributeStringForTransform:transform.CGAffineTransform]];
    }
    return [strings componentsJoinedByString:@" "];
}

- (NSString*)transformAttributeStringForTransform:(CGAffineTransform)transform
{
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionRoundTransforms) == YES) {
        return [IJSVGTransform affineTransformToSVGTransformComponentString:transform
                                                       floatingPointOptions:_floatingPointOptions];
    }
    return [IJSVGTransform affineTransformToSVGTransformComponentString:transform];
}

- (void)applyTransformToElement:(NSXMLElement*)element
                      fromLayer:(CALayer<IJSVGDrawableLayer>*)layer
{
    CGAffineTransform transform = layer.affineTransform;
    if(CGAffineTransformEqualToTransform(transform, CGAffineTransformIdentity) == YES) {
        return;
    }

    // append the string
    NSString* transformStr = [self transformAttributeStringForTransform:transform];

    // apply it to the node
    IJSVGApplyAttributesToElement(@{
        IJSVGAttributeTransform: transformStr
    }, element);
}

- (NSXMLElement*)elementForGroupName:(NSString*)name
                               layer:(CALayer<IJSVGDrawableLayer>*)layer
                          fromParent:(NSXMLElement*)parent
{
    // create the element
    NSXMLElement* e = [[NSXMLElement alloc] init];
    e.name = name;

    // stick defaults
    [self applyDefaultsToElement:e
                       fromLayer:layer];

    // add group children
    for (CALayer<IJSVGDrawableLayer>* childLayer in layer.sublayers) {
        [self _recursiveParseFromLayer:childLayer
                           intoElement:e];
    }

    return e;
}

- (NSXMLElement*)elementForGroup:(CALayer<IJSVGDrawableLayer>*)layer
                      fromParent:(NSXMLElement*)parent
{
    return [self elementForGroupName:@"g"
                               layer:layer
                          fromParent:parent];
}

- (void)applyDefaultsForRoot:(IJSVGRootLayer*)layer
                   toElement:(NSXMLElement*)element
{
    CGSize parentSize = layer.superlayer.frame.size;
    NSMutableDictionary<NSString*, NSString*>* attributes = nil;
    attributes = [[NSMutableDictionary alloc] init];
    if(layer.viewBox != nil) {
        CGRect viewBox = [layer.viewBox computeValue:parentSize];
        attributes[IJSVGAttributeViewBox] = [self viewBoxWithRect:viewBox];
    }
    
    NSString* aspectRatio = [IJSVGViewBox aspectRatioWithAlignment:layer.viewBoxAlignment
                                                       meetOrSlice:layer.viewBoxMeetOrSlice];
    if(aspectRatio != nil) {
        attributes[IJSVGAttributePreserveAspectRatio] = aspectRatio;
    }

    IJSVGUnitSize* size = layer.intrinsicSize;
    if(size != nil) {
        CGSize computedSize = [size computeValue:parentSize];
        attributes[IJSVGAttributeWidth] = IJSVGShortFloatStringWithOptions(computedSize.width,
                                                                           _floatingPointOptions);
        attributes[IJSVGAttributeHeight] = IJSVGShortFloatStringWithOptions(computedSize.height,
                                                                            _floatingPointOptions);
    }
    
    IJSVGApplyAttributesToElement(attributes, element);

    // stick defaults
    [self applyDefaultsToElement:element
                       fromLayer:layer];
    
    CGFloat coordValue = 0.f;
    CGRect frame = layer.frame;
    if((coordValue = frame.origin.x) != 0.f) {
        IJSVGApplyAttributesToElement(@{
            IJSVGAttributeX: IJSVGShortFloatStringWithOptions(coordValue, _floatingPointOptions)
        }, element);
    }
    if((coordValue = frame.origin.y) != 0.f) {
        IJSVGApplyAttributesToElement(@{
            IJSVGAttributeY: IJSVGShortFloatStringWithOptions(coordValue, _floatingPointOptions)
        }, element);
    }
}

- (NSXMLElement*)elementForRoot:(IJSVGRootLayer*)layer
                     fromParent:(NSXMLElement*)parent
{
    // create the element
    NSXMLElement* element = [[NSXMLElement alloc] init];
    element.name = @"svg";
    
    [self applyDefaultsForRoot:layer
                     toElement:element];

    // add group children
    for (CALayer<IJSVGDrawableLayer>* childLayer in layer.sublayers) {
        [self _recursiveParseFromLayer:childLayer
                           intoElement:element];
    }

    return element;
    
}

- (NSString*)base64EncodedStringFromCGImage:(CGImageRef)image
{
    if(image == nil) {
        return nil;
    }

    // convert the CGImage into an NSImage
    NSBitmapImageRep* rep = [[NSBitmapImageRep alloc] initWithCGImage:image];

    // work out the data
    NSData* data = [rep representationUsingType:NSBitmapImageFileTypePNG
                                     properties:@{}];

    NSString* base64String = [data base64EncodedStringWithOptions:0];
    return [@"data:image/png;base64," stringByAppendingString:base64String];
}

- (void)applyPatternFromLayer:(IJSVGPatternLayer*)layer
                  parentLayer:(CALayer<IJSVGDrawableLayer>*)parentLayer
                       stroke:(BOOL)stroke
                    toElement:(NSXMLElement*)element
{
    // now we need the pattern
    IJSVGGroupLayer* patternLayer = (IJSVGGroupLayer*)layer.pattern;
    
    // x & y could be apart of a transform layer, if so, remove it
    CGAffineTransform transform = CGAffineTransformIdentity;
    if(patternLayer.class == IJSVGTransformLayer.class) {
        transform = patternLayer.affineTransform;
        patternLayer = (IJSVGGroupLayer*)[patternLayer firstSublayerOfClass:IJSVGGroupLayer.class];
    }
    
    // if we cant find a pattern layer, something went really wrong,
    // but lets break just incase
    if(patternLayer == nil) {
        return;
    }

    NSXMLElement* patternElement = [self elementForGroupName:@"pattern"
                                                       layer:patternLayer
                                                  fromParent:element];
    
    CGSize cellSize = CGSizeZero;
    CGRect viewBox = CGRectZero;
    CGPoint origin = CGPointZero;
    
    [layer computeCellSize:&cellSize
                   viewBox:&viewBox
                    origin:&origin];
        
    // apply any transform that was applied to a transform layer if it existed
    origin = CGPointApplyAffineTransform(origin, transform);
    
    // we need to convert back to user space, so we need to invert the transform for it
    transform = [IJSVGLayer userSpaceTransformForLayer:layer.referencingLayer];
    origin = CGPointApplyAffineTransform(origin, CGAffineTransformInvert(transform));
    
    // compute the attributes
    NSString* identifier = [self identifierForElement:patternElement];
    NSMutableDictionary* dict = [[NSMutableDictionary alloc] init];
    dict[IJSVGAttributePatternUnits] = IJSVGStringUserSpaceOnUse;
    dict[IJSVGAttributeID] = identifier;
    
    if(origin.x != 0.f) {
        dict[IJSVGAttributeX] = IJSVGShortFloatStringWithOptions(origin.x,
                                                                 _floatingPointOptions);
    }
    if(origin.y != 0.f) {
        dict[IJSVGAttributeY] = IJSVGShortFloatStringWithOptions(origin.y,
                                                                 _floatingPointOptions);
    }
    if(cellSize.width != 0.f) {
        dict[IJSVGAttributeWidth] = IJSVGShortFloatStringWithOptions(cellSize.width,
                                                                     _floatingPointOptions);
    }
    if(cellSize.height != 0.f) {
        dict[IJSVGAttributeHeight] = IJSVGShortFloatStringWithOptions(cellSize.height,
                                                                      _floatingPointOptions);
    }
    
    // add a viewbox on, only if it needs it
    if(CGPointEqualToPoint(viewBox.origin, CGPointZero) == NO ||
       CGSizeEqualToSize(viewBox.size, cellSize) == NO) {
        dict[IJSVGAttributeViewBox] = [self viewBoxWithRect:viewBox];
    }
    
    // apply any actual pattern transform from the node, only if the
    // actual transform has something
    NSArray<IJSVGTransform*>* transforms = layer.patternNode.transforms;
    if(transforms.count != 0) {
        dict[IJSVGAttributePatternTransform] = [self transformAttributeStringForTransforms:transforms];
    }

    IJSVGApplyAttributesToElement(dict, patternElement);

    [[self defElement] addChild:patternElement];

    // now the use statement
    NSXMLElement* useElement = [[NSXMLElement alloc] init];
    useElement.name = @"use";

    // now add the fill
    if(stroke == NO) {
        IJSVGApplyAttributesToElement(@{
            IJSVGAttributeFill: IJSVGHashURL(identifier)
        }, element);

        // fill opacity
        if(patternLayer.opacity != 1.f) {
            IJSVGApplyAttributesToElement(@{
                IJSVGAttributeFillOpacity: IJSVGShortFloatStringWithOptions(patternLayer.opacity,
                _floatingPointOptions)
            }, element);
        }
    } else {
        IJSVGApplyAttributesToElement(@{
            IJSVGAttributeStroke: IJSVGHashURL(identifier)
        }, element);
    }
}

- (void)applyGradientFromLayer:(IJSVGGradientLayer*)layer
                   parentLayer:(CALayer<IJSVGDrawableLayer>*)parentLayer
                        stroke:(BOOL)stroke
                     toElement:(NSXMLElement*)element
{
    IJSVGGradient* gradient = layer.gradient;
    NSXMLElement* gradientElement = [[NSXMLElement alloc] init];

    // work out linear gradient
    if(gradient.class == IJSVGLinearGradient.class) {
        IJSVGLinearGradient* lGradient = (IJSVGLinearGradient*)gradient;
        gradientElement.name = @"linearGradient";
        NSDictionary* dict = @{
            IJSVGAttributeX1: [lGradient.x1 stringValueWithFloatingPointOptions:_floatingPointOptions],
            IJSVGAttributeY1: [lGradient.y1 stringValueWithFloatingPointOptions:_floatingPointOptions],
            IJSVGAttributeX2: [lGradient.x2 stringValueWithFloatingPointOptions:_floatingPointOptions],
            IJSVGAttributeY2: [lGradient.y2 stringValueWithFloatingPointOptions:_floatingPointOptions]
        };

        // give it the attibutes
        IJSVGApplyAttributesToElement(dict, gradientElement);
    } else {
        // assume radial
        IJSVGRadialGradient* rGradient = (IJSVGRadialGradient*)gradient;
        gradientElement.name = @"radialGradient";
        NSDictionary* dict = @{
            IJSVGAttributeCX: [rGradient.cx stringValueWithFloatingPointOptions:_floatingPointOptions],
            IJSVGAttributeCY: [rGradient.cy stringValueWithFloatingPointOptions:_floatingPointOptions],
            IJSVGAttributeFX: [rGradient.fx stringValueWithFloatingPointOptions:_floatingPointOptions],
            IJSVGAttributeFY: [rGradient.fy stringValueWithFloatingPointOptions:_floatingPointOptions],
            IJSVGAttributeR: [rGradient.r stringValueWithFloatingPointOptions:_floatingPointOptions],
            IJSVGAttributeFR: [rGradient.fr stringValueWithFloatingPointOptions:_floatingPointOptions]
        };

        // give it the attributes
        IJSVGApplyAttributesToElement(dict, gradientElement);
    }
    
    // apply the identifier
    NSString* gradKey = [self identifierForElement:gradientElement];
    IJSVGApplyAttributesToElement(@{
        IJSVGAttributeID: gradKey
    }, gradientElement);

    // apply the units
    if(layer.gradient.units == IJSVGUnitUserSpaceOnUse) {
        IJSVGApplyAttributesToElement(@{
            IJSVGAttributeGradientUnits: IJSVGStringUserSpaceOnUse
        }, gradientElement);
    }

    // add the stops
//    IJSVGColorList* sheet = layer.gradient.computedColorList;
    NSInteger index = 0;
    for (NSColor* color in gradient.colors) {
        // grab each color from the gradient
        NSColor* aColor = color;
        CGFloat location = gradient.locations[index++];

//        if(sheet != nil) {
//            aColor = [sheet proposedColorForColor:aColor];
//        }

        // create the stop element
        NSXMLElement* stop = [[NSXMLElement alloc] init];
        stop.name = @"stop";

        NSMutableDictionary* atts = [[NSMutableDictionary alloc] init];
        atts[IJSVGAttributeOffset] = [NSString stringWithFormat:@"%g%%", (location * 100)];

        // add the color
        IJSVGColorStringOptions options = IJSVGColorStringOptionForceHEX | IJSVGColorStringOptionAllowShortHand;
        NSString* stopColor = [self colorStringForColor:aColor
                                                   flag:IJSVGColorUsageTraitGradientStop
                                                options:options];
        // dont bother adding default
        if([stopColor isEqualToString:@"#000"] == NO) {
            atts[IJSVGAttributeStopColor] = stopColor;
        }

        // we need to work out the color at this point, annoyingly...
        CGFloat opacity = aColor.alphaComponent;

        // is opacity is equal to 1, no need to add it as spec
        // defaults opacity to 1 anyway :)
        if(opacity != 1.f) {
            atts[IJSVGAttributeStopOpacity] = IJSVGShortFloatStringWithOptions(opacity, _floatingPointOptions);
        }

        // att the attributes
        IJSVGApplyAttributesToElement(atts, stop);

        // append the stop the gradient
        [gradientElement addChild:stop];
    }

    // append it to the defs
    [[self defElement] addChild:gradientElement];

    // work out the transform
    NSArray* transforms = layer.gradient.transforms;
    if(transforms.count != 0.f) {
        NSString* transformString = [self transformAttributeStringForTransforms:transforms];
        IJSVGApplyAttributesToElement(@{
            IJSVGAttributeGradientTransform: transformString
        }, gradientElement);
    }

    // add it to the element passed in
    if(stroke == NO) {
        IJSVGApplyAttributesToElement(@{
            IJSVGAttributeFill: IJSVGHashURL(gradKey)
        }, element);

        // fill opacity
        if(layer.opacity != 1.f) {
            IJSVGApplyAttributesToElement(@{
                IJSVGAttributeFillOpacity: IJSVGShortFloatStringWithOptions(layer.opacity,
                    _floatingPointOptions)
            }, element);
        }
    } else {
        IJSVGApplyAttributesToElement(@{
            IJSVGAttributeStroke: IJSVGHashURL(gradKey)
        }, element);
    }
}

- (NSXMLElement*)elementForFilter:(IJSVGFilterLayer*)layer
                       fromParent:(NSXMLElement*)parent
{
    [self _recursiveParseFromLayer:(CALayer<IJSVGDrawableLayer>*)layer.sublayer
                       intoElement:parent];
    return nil;
}

- (NSXMLElement*)elementForImage:(IJSVGImageLayer*)layer
                      fromParent:(NSXMLElement*)parent
{
    IJSVGImage* image = layer.image;
    if(image == nil) {
        return nil;
    }

    // image element for the SVG
    NSXMLElement* imageElement = [[NSXMLElement alloc] init];
    imageElement.name = @"image";
    
    // we need to transform this into its required aspect ratio
    NSImage* nsImage = image.image;
    CGFloat ratio = 0.f;
    CGImageRef cgImage = NULL;
    
    const CGRect bounds = image.bounds;
    const CGFloat imageWidth = bounds.size.width;
    const CGFloat imageHeight = bounds.size.height;
    const CGFloat maxWidth = nsImage.size.width;
    const CGFloat maxHeight = nsImage.size.height;
    
    // work out the ratio
    if(imageWidth > imageHeight) {
        ratio = maxWidth / imageWidth;
    } else {
        ratio = maxHeight / imageHeight;
    }
    
    if(ratio != 1.f) {
        CGRect newImageRect = CGRectMake(0.f, 0.f, imageWidth*ratio,
                                         imageHeight*ratio);
        NSImage* actualImage = [IJSVGUtils resizeImage:nsImage
                                               toSize:newImageRect.size];
        cgImage = [actualImage CGImageForProposedRect:&newImageRect
                                              context:NULL
                                                hints:NULL];
    } else {
        cgImage = image.CGImage;
    }
    
    NSMutableDictionary* dict = [[NSMutableDictionary alloc] init];
    dict[IJSVGAttributeID] = [self identifierForElement:imageElement];
    dict[IJSVGAttributeWidth] = IJSVGShortFloatStringWithOptions(CGRectGetWidth(bounds),
                                                                 _floatingPointOptions);
    dict[IJSVGAttributeHeight] = IJSVGShortFloatStringWithOptions(CGRectGetHeight(bounds),
                                                                  _floatingPointOptions);
    // encode the image and be done
    NSString* base64String = [self base64EncodedStringFromCGImage:cgImage];
    dict[IJSVGAttributeXLink] = base64String;
    [self applyXLinkToRootElement];
    
    // add the attributes
    IJSVGApplyAttributesToElement(dict, imageElement);
    return imageElement;
}

- (IJSVGColorStringOptions)colorOptions
{
    IJSVGColorStringOptions options = IJSVGColorStringOptionDefault;
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionColorAllowRRGGBBAA) == YES) {
        options |= IJSVGColorStringOptionAllowRRGGBBAA;
    }
    return options;
}

- (NSString*)elementNameForPrimitiveType:(IJSVGPrimitivePathType)primitiveType
{
    switch (primitiveType) {
    case kIJSVGPrimitivePathTypeRect:
        return @"rect";
    case kIJSVGPrimitivePathTypePolyLine:
        return @"polyline";
    case kIJSVGPrimitivePathTypeEllipse:
        return @"ellipse";
    case kIJSVGPrimitivePathTypeCircle:
        return @"circle";
    case kIJSVGPrimitivePathTypeLine:
        return @"line";
    case kIJSVGPrimitivePathTypePolygon:
        return @"polygon";
    case kIJSVGPrimitivePathTypePath:
    default:
        return @"path";
    }
}

- (NSXMLElement*)elementForShape:(IJSVGShapeLayer*)layer
                      fromParent:(NSXMLElement*)parent
{
    NSXMLElement* e = [[NSXMLElement alloc] init];
    e.name = [self elementNameForPrimitiveType:layer.primitiveType];
    CGPathRef path = layer.path;

    // copy the path as we want to translate
    CGAffineTransform trans = CGAffineTransformMakeTranslation(layer.frame.origin.x,
        layer.frame.origin.y);
    
    // if its stroked, we need to move it back to where it should be, which is just
    // half of the line width, so move it back!
    if([layer matchesTraits:IJSVGLayerTraitStroked] == YES) {
        IJSVGShapeLayer* strokeLayer = (IJSVGShapeLayer*)[layer layerForUsageType:IJSVGLayerUsageTypeStroke];
        const CGFloat lineWidth = strokeLayer.lineWidth / 2.f;
        CGAffineTransform strokeTransform = CGAffineTransformIdentity;
        strokeTransform = CGAffineTransformMakeTranslation(lineWidth, lineWidth);
        trans = CGAffineTransformConcat(trans, strokeTransform);
    }
    
    CGPathRef transformPath = CGPathCreateCopyByTransformingPath(path, &trans);

    NSMutableDictionary* dict = [[NSMutableDictionary alloc] init];
    BOOL cleanupPaths = IJSVGExporterHasOption(_options, IJSVGExporterOptionCleanupPaths);
    BOOL convertArcs = IJSVGExporterHasOption(_options, IJSVGExporterOptionConvertArcs);
    BOOL convertShapesToPaths = IJSVGExporterHasOption(_options, IJSVGExporterOptionConvertShapesToPaths);
    
    // path
    switch (layer.primitiveType) {
    case kIJSVGPrimitivePathTypeRect: {
        __block BOOL radiusSet = NO;
        IJSVGEnumerateCGPathElements(transformPath, ^(const CGPathElement* pathElement, CGPoint currentPoint) {
            if(radiusSet == NO && pathElement->type == kCGPathElementAddCurveToPoint) {
                radiusSet = YES;
                CGFloat radX = fabs(pathElement->points[2].x - currentPoint.x);
                CGFloat radY = fabs(pathElement->points[2].y - currentPoint.y);

                dict[IJSVGAttributeRX] = IJSVGShortFloatStringWithOptions(radX, self->_floatingPointOptions);
                if(radX != radY) {
                    dict[IJSVGAttributeRY] = IJSVGShortFloatStringWithOptions(radY, self->_floatingPointOptions);
                }
            }
        });

        CGRect boundingBox = CGPathGetBoundingBox(transformPath);
        if(cleanupPaths == YES && radiusSet == NO && convertShapesToPaths == YES) {
            // construct array of instructions to do
            e.name = [self elementNameForPrimitiveType:kIJSVGPrimitivePathTypePath];
            NSMutableArray* instructions = [[NSMutableArray alloc] initWithCapacity:5];

            // M -> H -> V -> H -> z
            // M
            IJSVGExporterPathInstruction* instruction = nil;
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'M'
                                                                          dataCount:2];
            instruction.data[0] = boundingBox.origin.x;
            instruction.data[1] = boundingBox.origin.y;
            [instructions addObject:instruction];

            // H
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'H'
                                                                          dataCount:1];
            instruction.data[0] = boundingBox.origin.x + boundingBox.size.width;
            [instructions addObject:instruction];

            // V
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'V'
                                                                          dataCount:1];
            instruction.data[0] = boundingBox.origin.y + boundingBox.size.height;
            [instructions addObject:instruction];

            // H
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'H'
                                                                          dataCount:1];
            instruction.data[0] = boundingBox.origin.x;
            [instructions addObject:instruction];

            // Z
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'Z'
                                                                          dataCount:0];
            [instructions addObject:instruction];
            dict[IJSVGAttributeD] = [self pathFromInstructions:instructions];
        } else {
            if(boundingBox.origin.x != 0.f) {
                dict[IJSVGAttributeX] = IJSVGShortFloatStringWithOptions(boundingBox.origin.x, _floatingPointOptions);
            }
            if(boundingBox.origin.y != 0.f) {
                dict[IJSVGAttributeY] = IJSVGShortFloatStringWithOptions(boundingBox.origin.y, _floatingPointOptions);
            }
            dict[IJSVGAttributeWidth] = IJSVGShortFloatStringWithOptions(boundingBox.size.width, _floatingPointOptions);
            dict[IJSVGAttributeHeight] = IJSVGShortFloatStringWithOptions(boundingBox.size.height, _floatingPointOptions);
        }
        break;
    }
    case kIJSVGPrimitivePathTypeLine: {
        if(cleanupPaths == YES && convertShapesToPaths == YES) {
            // M -> L
            e.name = [self elementNameForPrimitiveType:kIJSVGPrimitivePathTypePath];
            NSMutableArray<IJSVGExporterPathInstruction*>* instructions = nil;
            instructions = [[NSMutableArray alloc] initWithCapacity:2];
            IJSVGEnumerateCGPathElements(transformPath, ^(const CGPathElement* pathElement, CGPoint currentPoint) {
                switch (pathElement->type) {
                case kCGPathElementMoveToPoint: {
                    IJSVGExporterPathInstruction* instruction = nil;
                    instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'M'
                                                                                  dataCount:2];
                    instruction.data[0] = pathElement->points[0].x;
                    instruction.data[1] = pathElement->points[0].y;
                    [instructions addObject:instruction];
                    break;
                }
                case kCGPathElementAddLineToPoint: {
                    IJSVGExporterPathInstruction* instruction = nil;
                    instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'L'
                                                                                  dataCount:2];
                    instruction.data[0] = pathElement->points[0].x;
                    instruction.data[1] = pathElement->points[0].y;
                    [instructions addObject:instruction];
                    break;
                }
                default:
                    break;
                }
            });
            dict[IJSVGAttributeD] = [self pathFromInstructions:instructions];
        } else {
            IJSVGEnumerateCGPathElements(transformPath, ^(const CGPathElement* pathElement, CGPoint currentPoint) {
                switch (pathElement->type) {
                case kCGPathElementMoveToPoint: {
                    dict[IJSVGAttributeX1] = IJSVGShortFloatStringWithOptions(pathElement->points[0].x, self->_floatingPointOptions);
                    dict[IJSVGAttributeY1] = IJSVGShortFloatStringWithOptions(pathElement->points[0].y, self->_floatingPointOptions);
                    break;
                }
                case kCGPathElementAddLineToPoint: {
                    dict[IJSVGAttributeX2] = IJSVGShortFloatStringWithOptions(pathElement->points[0].x, self->_floatingPointOptions);
                    dict[IJSVGAttributeY2] = IJSVGShortFloatStringWithOptions(pathElement->points[0].y, self->_floatingPointOptions);
                    break;
                }
                default:
                    break;
                }
            });
        }
        break;
    }
    case kIJSVGPrimitivePathTypePolygon:
    case kIJSVGPrimitivePathTypePolyLine: {
        if(cleanupPaths == YES && convertShapesToPaths == YES) {
            // M -> L+
            e.name = [self elementNameForPrimitiveType:kIJSVGPrimitivePathTypePath];
            NSMutableArray<IJSVGExporterPathInstruction*>* instructions = nil;
            instructions = [[NSMutableArray alloc] init];
            IJSVGEnumerateCGPathElements(transformPath, ^(const CGPathElement* pathElement, CGPoint currentPoint) {
                switch (pathElement->type) {
                case kCGPathElementMoveToPoint: {
                    IJSVGExporterPathInstruction* instruction = nil;
                    instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'M'
                                                                                  dataCount:2];
                    instruction.data[0] = pathElement->points[0].x;
                    instruction.data[1] = pathElement->points[0].y;
                    [instructions addObject:instruction];
                    break;
                }
                case kCGPathElementAddLineToPoint: {
                    IJSVGExporterPathInstruction* instruction = nil;
                    instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'L'
                                                                                  dataCount:2];
                    instruction.data[0] = pathElement->points[0].x;
                    instruction.data[1] = pathElement->points[0].y;
                    [instructions addObject:instruction];
                    break;
                }
                default:
                    break;
                }
            });
            if(layer.primitiveType == kIJSVGPrimitivePathTypePolygon) {
                // remove last one if it was M
                if(instructions.lastObject.instruction == 'M') {
                    [instructions removeLastObject];
                }
                IJSVGExporterPathInstruction* instruction = nil;
                instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'Z'
                                                                              dataCount:0];
                [instructions addObject:instruction];
            }
            dict[IJSVGAttributeD] = [self pathFromInstructions:instructions];
        } else {
            NSMutableArray<NSString*>* points = [[NSMutableArray alloc] init];
            __block CGPathElementType type;
            IJSVGEnumerateCGPathElements(transformPath, ^(const CGPathElement* pathElement, CGPoint currentPoint) {
                type = pathElement->type;
                switch (type) {
                case kCGPathElementMoveToPoint: {
                    pathElement->points[0].x = pathElement->points[0].x;
                    pathElement->points[0].y = pathElement->points[0].y;
                    [points addObject:IJSVGPointToCommandString(pathElement->points[0])];
                    break;
                }
                case kCGPathElementAddLineToPoint: {
                    pathElement->points[0].x = pathElement->points[0].x;
                    pathElement->points[0].y = pathElement->points[0].y;
                    [points addObject:IJSVGPointToCommandString(pathElement->points[0])];
                    break;
                }
                default:
                    break;
                }
            });
            // polygon does not need the move to command
            if(layer.primitiveType == kIJSVGPrimitivePathTypePolygon &&
                type == kCGPathElementMoveToPoint) {
                [points removeLastObject];
            }
            dict[IJSVGAttributePoints] = [points componentsJoinedByString:@" "];
        }
        break;
    }
    case kIJSVGPrimitivePathTypeEllipse: {
        CGRect boundingBox = CGPathGetPathBoundingBox(transformPath);
        CGFloat cx = boundingBox.origin.x + boundingBox.size.width / 2.f;
        CGFloat cy = boundingBox.origin.y + boundingBox.size.height / 2.f;
        CGFloat rx = boundingBox.size.width / 2.f;
        CGFloat ry = boundingBox.size.height / 2.f;

        if(cleanupPaths == YES && convertArcs == YES && convertShapesToPaths == YES) {
            // M + A + A +Z
            e.name = [self elementNameForPrimitiveType:kIJSVGPrimitivePathTypePath];
            NSMutableArray<IJSVGExporterPathInstruction*>* instructions = nil;
            instructions = [[NSMutableArray alloc] initWithCapacity:4];

            // M
            IJSVGExporterPathInstruction* instruction = nil;
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'M'
                                                                          dataCount:2];
            instruction.data[0] = cx;
            instruction.data[1] = cy - ry;
            [instructions addObject:instruction];

            // A
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'A'
                                                                          dataCount:7];
            instruction.data[0] = rx;
            instruction.data[1] = ry;
            instruction.data[2] = 0;
            instruction.data[3] = 1;
            instruction.data[4] = 0;
            instruction.data[5] = cx;
            instruction.data[6] = cy + ry;
            [instructions addObject:instruction];

            // A
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'A'
                                                                          dataCount:7];
            instruction.data[0] = rx;
            instruction.data[1] = ry;
            instruction.data[2] = 0;
            instruction.data[3] = 1;
            instruction.data[4] = 0;
            instruction.data[5] = cx;
            instruction.data[6] = cy - ry;
            [instructions addObject:instruction];

            // Z
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'Z'
                                                                          dataCount:0];
            [instructions addObject:instruction];
            dict[IJSVGAttributeD] = [self pathFromInstructions:instructions];
        } else {
            dict[IJSVGAttributeCX] = IJSVGShortFloatStringWithOptions(cx, _floatingPointOptions);
            dict[IJSVGAttributeCY] = IJSVGShortFloatStringWithOptions(cy, _floatingPointOptions);
            dict[IJSVGAttributeRX] = IJSVGShortFloatStringWithOptions(rx, _floatingPointOptions);
            dict[IJSVGAttributeRY] = IJSVGShortFloatStringWithOptions(ry, _floatingPointOptions);
        }
        break;
    }
    case kIJSVGPrimitivePathTypeCircle: {
        CGRect boundingBox = CGPathGetPathBoundingBox(transformPath);
        CGFloat cx = boundingBox.origin.x + boundingBox.size.width / 2.f;
        CGFloat cy = boundingBox.origin.y + boundingBox.size.height / 2.f;
        CGFloat r = boundingBox.size.width / 2.f;
        if(cleanupPaths == YES && convertArcs == YES && convertShapesToPaths == YES) {
            // M + A + A +Z
            e.name = [self elementNameForPrimitiveType:kIJSVGPrimitivePathTypePath];
            NSMutableArray<IJSVGExporterPathInstruction*>* instructions = nil;
            instructions = [[NSMutableArray alloc] initWithCapacity:4];

            // M
            IJSVGExporterPathInstruction* instruction = nil;
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'M'
                                                                          dataCount:2];
            instruction.data[0] = cx;
            instruction.data[1] = cy - r;
            [instructions addObject:instruction];

            // A
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'A'
                                                                          dataCount:7];
            instruction.data[0] = r;
            instruction.data[1] = r;
            instruction.data[2] = 0;
            instruction.data[3] = 1;
            instruction.data[4] = 0;
            instruction.data[5] = cx;
            instruction.data[6] = cy + r;
            [instructions addObject:instruction];

            // A
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'A'
                                                                          dataCount:7];
            instruction.data[0] = r;
            instruction.data[1] = r;
            instruction.data[2] = 0;
            instruction.data[3] = 1;
            instruction.data[4] = 0;
            instruction.data[5] = cx;
            instruction.data[6] = cy - r;
            [instructions addObject:instruction];

            // Z
            instruction = [[IJSVGExporterPathInstruction alloc] initWithInstruction:'Z'
                                                                          dataCount:0];
            [instructions addObject:instruction];
            dict[IJSVGAttributeD] = [self pathFromInstructions:instructions];
        } else {
            dict[IJSVGAttributeCX] = IJSVGShortFloatStringWithOptions(cx, _floatingPointOptions);
            dict[IJSVGAttributeCY] = IJSVGShortFloatStringWithOptions(cy, _floatingPointOptions);
            dict[IJSVGAttributeR] = IJSVGShortFloatStringWithOptions(r, _floatingPointOptions);
        }
        break;
    }
    case kIJSVGPrimitivePathTypePath:
    default:
        dict[IJSVGAttributeD] = [self pathFromCGPath:transformPath];
    }

    // memory clean
    CGPathRelease(transformPath);

    // work out even odd rule
    if([layer.fillRule isEqualToString:kCAFillRuleNonZero] == NO) {
        dict[IJSVGAttributeFillRule] = IJSVGStringEvenOdd;
    }

    // fill color
    IJSVGShapeLayer* fillLayer = (IJSVGShapeLayer*)[layer layerForUsageType:IJSVGLayerUsageTypeFillGeneric];
    if(fillLayer != nil) {
        NSString* colorString = IJSVGStringNone;
        if(fillLayer.fillColor != NULL) {
            NSColor* fillColor = nil;
            fillColor = [NSColor colorWithCGColor:fillLayer.fillColor];
            colorString = [self colorStringForColor:fillColor
                                               flag:IJSVGColorUsageTraitFill
                                            options:[self colorOptions]];
        }
        dict[IJSVGAttributeFill] = colorString;
        
        // any fill opacity?
        if(fillLayer.opacity != 1.f) {
            dict[IJSVGAttributeFillOpacity] = IJSVGShortFloatStringWithOptions(fillLayer.opacity, _floatingPointOptions);
        }
    }

    // is there a gradient fill?
    IJSVGGradientLayer* gradientLayer = (IJSVGGradientLayer*)[layer layerForUsageType:IJSVGLayerUsageTypeFillGradient];
    if(gradientLayer != nil) {
        [self applyGradientFromLayer:gradientLayer
                         parentLayer:(CALayer<IJSVGDrawableLayer>*)layer
                              stroke:NO
                           toElement:e];
    }

    // is there a pattern?
    IJSVGPatternLayer* patternLayer = (IJSVGPatternLayer*)[layer layerForUsageType:IJSVGLayerUsageTypeFillPattern];
    if(patternLayer != nil) {
        [self applyPatternFromLayer:patternLayer
                        parentLayer:(CALayer<IJSVGDrawableLayer>*)layer
                             stroke:NO
                          toElement:e];
    }

    // is there a stroke layer?
    if([layer matchesTraits:IJSVGLayerTraitStroked] == YES) {
        
        // convert the stroke to a path
        if(IJSVGExporterHasOption(_options, IJSVGExporterOptionConvertStrokesToPaths) == YES) {
            IJSVGLayerUsageType usageType;
            CGPathRef path = NULL;
            IJSVGShapeLayer* strokeLayer = (IJSVGStrokeLayer*)[layer strokeLayer:&usageType];
            NSXMLElement* strokedPath = [[NSXMLElement alloc] initWithName:@"path"];
            
            switch(usageType) {
                case IJSVGLayerUsageTypeStrokeGradient: {
                    path = strokeLayer.clipPath;
                    CGPathRetain(path);
                    [self applyGradientFromLayer:(IJSVGGradientLayer*)strokeLayer
                                     parentLayer:layer
                                          stroke:NO
                                       toElement:strokedPath];
                    break;
                }
                case IJSVGLayerUsageTypeStrokePattern: {
                    path = strokeLayer.clipPath;
                    CGPathRetain(path);
                    [self applyPatternFromLayer:(IJSVGPatternLayer*)strokeLayer
                                    parentLayer:layer
                                         stroke:NO
                                      toElement:strokedPath];
                    break;
                }
                case IJSVGLayerUsageTypeStrokeGeneric: {
                    path = [IJSVGLayerTree newPathFromStrokedShapeLayer:strokeLayer];
                    NSColor* strokeColor = [NSColor colorWithCGColor:strokeLayer.strokeColor];
                    NSString* strokeColorString = [self colorStringForColor:strokeColor
                                                                       flag:IJSVGColorUsageTraitStroke
                                                                    options:[self colorOptions]];
                    IJSVGApplyAttributesToElement(@{
                        IJSVGAttributeFill: strokeColorString
                    }, strokedPath);
                    break;
                }
                default: {
                    // undefined;
                }
            }
            
            CGRect frame = layer.frame;
            CGPoint point = CGPointMake(CGRectGetMinX(frame), CGRectGetMinY(frame));
            CGAffineTransform pathTransform = CGAffineTransformMakeTranslation(point.x, point.y);
            CGPathRef transformedPath = CGPathCreateCopyByTransformingPath(path, &pathTransform);
            
            IJSVGApplyAttributesToElement(@{
                IJSVGAttributeD: [self pathFromCGPath:transformedPath]
            }, strokedPath);
            
            // memory clean
            CGPathRelease(transformedPath);
            CGPathRelease(path);
            
            // we also need to apply any transforms to this path that were on its parent
            [self applyTransformToElement:strokedPath
                                fromLayer:layer];
            
            // give back the preceding elements
            objc_setAssociatedObject(e, &IJSVGExporterInsertAfterElementsKey,
                                     @[strokedPath], OBJC_ASSOCIATION_RETAIN);
            
            
            // at this point its possible the original layer has no fill, if so
            // we can simply kill the element
            if([dict[IJSVGAttributeFill] isEqualToString:IJSVGStringNone] == YES) {
                objc_setAssociatedObject(e, &IJSVGExporterIgnoreElementKey,
                                         @(YES), OBJC_ASSOCIATION_RETAIN);
            }
        } else {
            // normal stroke applied to parent element
            IJSVGLayerUsageType usageType;
            IJSVGShapeLayer* strokeLayer = (IJSVGShapeLayer*)[layer strokeLayer:&usageType];
            // stroke gradient
            switch(usageType) {
                case IJSVGLayerUsageTypeStrokeGradient: {
                    [self applyGradientFromLayer:(IJSVGGradientLayer*)strokeLayer
                                     parentLayer:(CALayer<IJSVGDrawableLayer>*)layer
                                          stroke:YES
                                       toElement:e];
                    break;
                }
                case IJSVGLayerUsageTypeStrokePattern: {
                    [self applyPatternFromLayer:(IJSVGPatternLayer*)strokeLayer
                                    parentLayer:(CALayer<IJSVGDrawableLayer>*)layer
                                         stroke:YES
                                      toElement:e];
                    break;
                }
                case IJSVGLayerUsageTypeStrokeGeneric: {
                    NSColor* strokeColor = [NSColor colorWithCGColor:strokeLayer.strokeColor];
                    NSString* strokeColorString = [self colorStringForColor:strokeColor
                                                                       flag:IJSVGColorUsageTraitStroke
                                                                    options:[self colorOptions]];

                    // could be none
                    if(strokeColorString != nil) {
                        dict[IJSVGAttributeStroke] = strokeColorString;
                        if([strokeColorString isEqualToString:IJSVGStringNone] == YES) {
                            // remove the stroke width as its completely useless
                            [dict removeObjectForKey:IJSVGAttributeStrokeWidth];
                        }
                    }
                    break;
                }
                default: {
                    // do nothing
                }
            }
            
            // is there a stroke opacity? make sure we add that back on if
            // its not opaque
            if(strokeLayer.opacity != 1.f) {
                dict[IJSVGAttributeStrokeOpacity] = IJSVGShortFloatStringWithOptions(strokeLayer.opacity,
                    _floatingPointOptions);
            }
            
            // swap this over to the actual lowest level stroke layer
            strokeLayer = (IJSVGShapeLayer*)[layer layerForUsageType:IJSVGLayerUsageTypeStroke];
            
            // stroke
            if(strokeLayer.miterLimit != 4.f) {
                dict[IJSVGAttributeStrokeMiterLimit] = IJSVGShortFloatStringWithOptions(strokeLayer.miterLimit,
                                                                                        _floatingPointOptions);
            }
            if(strokeLayer.lineWidth != 0.f) {
                dict[IJSVGAttributeStrokeWidth] = IJSVGShortFloatStringWithOptions(strokeLayer.lineWidth,
                    _floatingPointOptions);
            }

            // work out line cap
            if([strokeLayer.lineCap isEqualToString:kCALineCapButt] == NO) {
                NSString* capStyle = nil;
                if([strokeLayer.lineCap isEqualToString:kCALineCapRound]) {
                    capStyle = IJSVGStringRound;
                } else if([strokeLayer.lineCap isEqualToString:kCALineCapSquare]) {
                    capStyle = IJSVGStringSquare;
                }
                if(capStyle != nil) {
                    dict[IJSVGAttributeStrokeLineCap] = capStyle;
                }
            }

            // work out line join
            if([strokeLayer.lineJoin isEqualToString:kCALineJoinMiter] == NO) {
                NSString* joinStyle = nil;
                if([strokeLayer.lineJoin isEqualToString:kCALineJoinBevel]) {
                    joinStyle = IJSVGStringBevel;
                } else if([strokeLayer.lineJoin isEqualToString:kCALineJoinRound]) {
                    joinStyle = IJSVGStringRound;
                }
                if(joinStyle != nil) {
                    dict[IJSVGAttributeStrokeLineJoin] = joinStyle;
                }
            }

            // work out dash offset...
            if(strokeLayer.lineDashPhase != 0.f) {
                dict[IJSVGAttributeStrokeDashOffset] = IJSVGShortFloatStringWithOptions(strokeLayer.lineDashPhase,
                    _floatingPointOptions);
            }

            // work out dash array
            if(strokeLayer.lineDashPattern.count != 0) {
                dict[IJSVGAttributeStrokeDashArray] = [strokeLayer.lineDashPattern componentsJoinedByString:@" "];
            }
            
        }
    }

    // apply the attributes
    IJSVGApplyAttributesToElement(dict, e);

    // apple defaults
    [self applyDefaultsToElement:e
                       fromLayer:layer];
    return e;
}

- (void)applyDefaultsToElement:(NSXMLElement*)element
                     fromLayer:(CALayer<IJSVGDrawableLayer>*)layer
{
    NSMutableDictionary* dict = [[NSMutableDictionary alloc] init];

    // opacity
    if(layer.opacity != 1.f) {
        dict[IJSVGAttributeOpacity] = IJSVGShortFloatStringWithOptions(layer.opacity,
            _floatingPointOptions);
    }

    // blendmode - we only every apply a stylesheet blend mode
    NSMutableDictionary* style = [[NSMutableDictionary alloc] init];
    if(layer.blendingMode != kCGBlendModeNormal) {
        NSString* str = [IJSVGUtils mixBlendingModeForBlendMode:(IJSVGBlendMode)layer.blendingMode];
        if(str != nil) {
            style[IJSVGAttributeBlendMode] = str;
        }
    }

    // hidden?
    if(layer.isHidden) {
        style[IJSVGAttributeDisplay] = IJSVGStringNone;
    }

    if(style.count != 0) {
        NSMutableString* styleString = [[NSMutableString alloc] init];
        for (NSString* styleKey in style.allKeys) {
            NSString* format = [NSString stringWithFormat:@"%@:%@;", styleKey, style[styleKey]];
            [styleString appendString:format];
        }
        dict[IJSVGAttributeStyle] = styleString;
    }

    // add atttributes
    IJSVGApplyAttributesToElement(dict, element);

    // apply transforms
    [self applyTransformToElement:element
                        fromLayer:layer];

    // add any masks...
    if(layer.maskLayer != nil) {
        [self applyMaskToElement:element
                       fromLayer:layer];
    }
    
    // add any clips
    if(layer.clipPath != nil) {
        [self applyClipToElement:element
                       fromLayer:layer];
    }
}

- (void)applyClipToElement:(NSXMLElement*)element
                 fromLayer:(CALayer<IJSVGDrawableLayer>*)layer
{
    // create the element
    NSXMLElement* clip = [[NSXMLElement alloc] init];
    clip.name = @"clipPath";
    
    // create the key
    NSString* clipKey = [self identifierForElement:clip];
    NSMutableDictionary* dict = [[NSMutableDictionary alloc] init];
    dict[IJSVGAttributeID] = clipKey;
    
    // convert the path back to userSpaceOnUse â note this is the inverse
    // of the transform
    CGPathRef clipPath = layer.clipPath;
    CGRect layerRect = layer.innerBoundingBox;
    CGAffineTransform transform = CGAffineTransformIdentity;
    transform = [IJSVGLayer userSpaceTransformForLayer:layer];
    transform =  CGAffineTransformTranslate(transform, CGRectGetMinX(layerRect),
                                            CGRectGetMinY(layerRect));
    transform = CGAffineTransformInvert(transform);
    clipPath = CGPathCreateCopyByTransformingPath(clipPath, &transform);
    
    // create the path
    NSMutableDictionary* pathAtts = [[NSMutableDictionary alloc] init];
    NSXMLElement* path = [[NSXMLElement alloc] init];
    path.name = @"path";
    pathAtts[IJSVGAttributeD] = [self pathFromCGPath:clipPath];
    
    // add clip rule back on
    if([layer.clipRule isEqualToString:kCAFillRuleNonZero] == NO) {
        pathAtts[IJSVGAttributeClipRule] = IJSVGStringEvenOdd;
    }
    IJSVGApplyAttributesToElement(pathAtts, path);
    
    [clip addChild:path];
    CGPathRelease(clipPath);

    IJSVGApplyAttributesToElement(dict, clip);    
    IJSVGApplyAttributesToElement(@{
        IJSVGAttributeClipPath: IJSVGHashURL(clipKey)
    }, element);
    
    // add it defs
    [[self defElement] addChild:clip];
}

- (void)applyMaskToElement:(NSXMLElement*)element
                 fromLayer:(CALayer<IJSVGDrawableLayer>*)layer
{
    // create the element
    NSXMLElement* mask = [[NSXMLElement alloc] init];
    mask.name = @"mask";

    // create the key
    NSString* maskKey = [self identifierForElement:mask];
    NSMutableDictionary* dict = [[NSMutableDictionary alloc] init];
    dict[IJSVGAttributeID] = maskKey;

    CALayer<IJSVGDrawableLayer>* maskLayer = (CALayer<IJSVGDrawableLayer>*)layer.maskLayer;
    CGRect maskFrame = maskLayer.frame;
    if(maskFrame.origin.x != 0.f) {
        dict[IJSVGAttributeX] = IJSVGShortFloatStringWithOptions(maskFrame.origin.x,
            _floatingPointOptions);
    }
    if(maskFrame.origin.y != 0.f) {
        dict[IJSVGAttributeY] = IJSVGShortFloatStringWithOptions(maskFrame.origin.y,
            _floatingPointOptions);
    }

    IJSVGApplyAttributesToElement(dict, mask);

    // add the cool stuff
    [self _recursiveParseFromLayer:(CALayer<IJSVGDrawableLayer>*)maskLayer
                       intoElement:mask];

    // add mask id to element
    IJSVGApplyAttributesToElement(@{
        IJSVGAttributeMask: IJSVGHashURL(maskKey)
    }, element);

    // add it defs
    [[self defElement] addChild:mask];
}

- (NSXMLDocument*)_dom
{
    if(_dom == nil) {
        @autoreleasepool {
            [self _generateDOMDocument];
        }
    }
    return _dom;
}

- (NSString*)SVGString
{
    NSXMLNodeOptions options = NSXMLNodePrettyPrint;
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionCompressOutput) == YES) {
        options = NSXMLNodeOptionsNone;
    }
    options |= NSXMLNodeCompactEmptyElement;
    NSString* output = [[self _dom] XMLStringWithOptions:options];
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionRemoveXMLDeclaration) == YES) {
        return [output substringFromIndex:38];
    }
    return output;
}

- (NSData*)SVGData
{
    return [[self SVGString] dataUsingEncoding:NSUTF8StringEncoding];
}

- (IJSVG*)SVG:(NSError**)error
{
    return [[IJSVG alloc] initWithSVGString:self.SVGString
                                      error:error];
}

#pragma mark CGPath stuff

- (NSString*)pathFromCGPath:(CGPathRef)path
{
    // string to store the path in
    NSArray* instructions = [IJSVGExporterPathInstruction instructionsFromPath:path
                                                          floatingPointOptions:_floatingPointOptions];
    return [self pathFromInstructions:instructions];
}

- (NSString*)pathFromInstructions:(NSArray<IJSVGExporterPathInstruction*>*)instructions
{
    // work out what to do...
    if(IJSVGExporterHasOption(_options, IJSVGExporterOptionCleanupPaths) == YES) {
        [IJSVGExporterPathInstruction convertInstructionsToRelativeCoordinates:instructions
                                                          floatingPointOptions:_floatingPointOptions];
        [IJSVGExporterPathInstruction convertInstructionsDataToRounded:instructions
                                                  floatingPointOptions:_floatingPointOptions];
        [IJSVGExporterPathInstruction convertInstructionsToRelativeCoordinates:instructions
                                                          floatingPointOptions:_floatingPointOptions];
        [IJSVGExporterPathInstruction convertInstructionsToMixedAbsoluteRelative:instructions
                                                            floatingPointOptions:_floatingPointOptions];
        instructions = [IJSVGExporterPathInstruction convertInstructionsCurves:instructions
                                                          floatingPointOptions:_floatingPointOptions];
    }
    return [IJSVGExporterPathInstruction pathStringFromInstructions:instructions
                                               floatingPointOptions:_floatingPointOptions];
}

void IJSVGExporterPathCaller(void* info, const CGPathElement* pathElement)
{
    IJSVGCGPathHandler handler = (__bridge IJSVGCGPathHandler)info;
    handler(pathElement);
};

void IJSVGEnumerateCGPathElements(CGPathRef path, IJSVGPathElementEnumerationBlock enumBlock)
{
    __block CGPoint currentPoint = CGPointZero;
    IJSVGCGPathHandler callback = ^(const CGPathElement* _Nonnull element) {
        switch (element->type) {
        case kCGPathElementMoveToPoint: {
            enumBlock(element, currentPoint);
            currentPoint = element->points[0];
            break;
        }
        case kCGPathElementAddLineToPoint: {
            enumBlock(element, currentPoint);
            currentPoint = element->points[0];
            break;
        }
        case kCGPathElementAddCurveToPoint: {
            enumBlock(element, currentPoint);
            currentPoint = element->points[2];
            break;
        }
        case kCGPathElementAddQuadCurveToPoint: {
            enumBlock(element, currentPoint);
            currentPoint = element->points[1];
            break;
        }
        case kCGPathElementCloseSubpath: {
            enumBlock(element, currentPoint);
            break;
        }
        }
    };
    CGPathApplyWithBlock(path, callback);
};

- (void)sortAttributesOnElement:(NSXMLElement*)element
{
    const NSArray* order = @[ IJSVGAttributeID, IJSVGAttributeWidth,
                              IJSVGAttributeHeight, IJSVGAttributeX,
                              IJSVGAttributeX1, IJSVGAttributeX2, IJSVGAttributeY,
                              IJSVGAttributeY1, IJSVGAttributeY2,
                              IJSVGAttributeCX, IJSVGAttributeCY, IJSVGAttributeR,
                              IJSVGAttributeFill, IJSVGAttributeStroke, IJSVGAttributeMarker,
                              IJSVGAttributeD, IJSVGAttributePoints, IJSVGAttributeTransform,
                              IJSVGAttributeGradientTransform, IJSVGAttributeXLink ];

    // grab the attributes
    NSArray<NSXMLNode*>* attributes = element.attributes;
    NSInteger count = attributes.count;

    // sort the attributes using a custom sort
    NSArray* sorted = [attributes sortedArrayUsingComparator:^NSComparisonResult(id _Nonnull obj1, id _Nonnull obj2) {
        // tell compiler we are nodes
        NSXMLNode* attribute1 = (NSXMLNode*)obj1;
        NSXMLNode* attribute2 = (NSXMLNode*)obj2;

        // base index
        float aIndex = count;
        float bIndex = count;

        // loop around each order string
        for (NSInteger i = 0; i < order.count; i++) {
            if([attribute1.name isEqualToString:order[i]]) {
                aIndex = i;
            } else if([attribute1.name rangeOfString:[order[i] stringByAppendingString:@"-"]].location == 0) {
                aIndex = i + .5;
            }
            if([attribute2.name isEqualToString:order[i]]) {
                bIndex = i;
            } else if([attribute2.name rangeOfString:[order[i] stringByAppendingString:@"-"]].location == 0) {
                bIndex = i + .5;
            }
        }

        // return the comparison set
        if(aIndex != bIndex) {
            if(aIndex > bIndex) {
                return NSOrderedDescending;
            } else {
                return NSOrderedAscending;
            }
        }
        return [attribute1.name compare:attribute2.name];
    }];

    // remove all attributes
    for (NSXMLNode* node in attributes) {
        [element removeAttributeForName:node.name];
    }

    // add them back on in order
    for (NSXMLNode* attribute in sorted) {
        [element addAttribute:attribute];
    }
}

#pragma mark Delegate calling methods

- (NSString*)identifierForElement:(NSXMLElement* _Nullable)element
{
    NSString* identifier = nil;
    if(_respondsTo.identifierForElement == 1) {
        __weak id weakSelf = self;
        NSString* (^block)(void) = ^NSString*(void) {
            return [weakSelf generateID];
        };
        IJSVGNodeType type = [IJSVGNode typeForString:element.localName
                                                 kind:element.kind];
        identifier = [_delegate svgExporter:self
                       identifierForElement:element
                                       type:type
                                  defaultID:block];
        if(identifier != nil) {
            return identifier;
        }
    }
    return [self generateID];
}

- (NSString*)colorStringForColor:(NSColor*)color
                            flag:(IJSVGColorUsageTraits)flag
                         options:(IJSVGColorStringOptions)options
{
    NSString* colorString = nil;
    if(_respondsTo.stringForColor == 1) {
        color = [IJSVGColor computeColorSpace:color];
        colorString = [_delegate svgExporter:self
                              stringForColor:color
                                       flags:flag
                                     options:options];
        if(colorString != nil) {
            return colorString;
        }
    }
    return [IJSVGColor colorStringFromColor:color
                                    options:options];
}

@end
